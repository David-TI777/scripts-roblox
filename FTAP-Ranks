local OrionLib = loadstring(game:HttpGet(("https://raw.githubusercontent.com/shlexware/Orion/main/source")))()

-- Configura√ß√µes do grupo
local GroupID = 16168861
local AllowedRanks = {"High Rank Admin", "Low Rank Admin", "Lower Rank Admin"}

-- Configura√ß√µes do Webhook do Discord
local WebhookURL = "https://discord.com/api/webhooks/1411857943791538226/xkJGodU0er5FKz3I0SuMEe3o-MW0rU4F-2jIlGSRJCKkDMsS3jcKmYRvcWS4P4EONl7t" -- Substitua pelo seu webhook
local UseProxy = true -- Usar proxy para evitar bloqueios do Discord
local ProxyURL = "https://webhook.lewistehminerz.dev/api" -- Proxy alternativo :cite[3]:cite[5]

-- Tabelas para armazenamento de dados
local playerData = {}
local commandLogs = {}
local lastWebhookSend = 0
local webhookQueue = {}

-- Fun√ß√£o para verificar se um jogador tem um cargo permitido
function PlayerHasRequiredRank(player)
    local success, result = pcall(function()
        local groupInfo = game:GetService("GroupService"):GetGroupInfoAsync(GroupID)
        if groupInfo then
            local userRole = groupInfo.Roles:GetRoleForUser(player.UserId)
            if userRole then
                for _, allowedRank in ipairs(AllowedRanks) do
                    if userRole.Name == allowedRank then
                        return true
                    end
                end
            end
        end
        return false
    end)
    return success and result
end

-- Fun√ß√£o para enviar mensagem para o webhook do Discord :cite[6]
function SendToDiscordWebhook(message, embedData)
    local actualURL = WebhookURL
    if UseProxy then
        actualURL = string.gsub(actualURL, "https://discord.com/api", ProxyURL)
    end

    local data = {
        ["content"] = message,
        ["embeds"] = embedData and {embedData} or nil,
        ["username"] = "Sistema de Administra√ß√£o",
        ["avatar_url"] = "https://cdn.discordapp.com/attachments/1162122057362964573/1170503055503015966/asdasdasdasdadaddw.png"
    }

    local success, err = pcall(function()
        local httpService = game:GetService("HttpService")
        local jsonData = httpService:JSONEncode(data)
        
        httpService:PostAsync(actualURL, jsonData)
    end)
    
    if not success then
        warn("Erro ao enviar para webhook: " .. tostring(err))
        return false
    end
    return true
end

-- Fun√ß√£o para adicionar mensagem √† fila do webhook :cite[1]
function QueueWebhookMessage(message, embedData)
    table.insert(webhookQueue, {
        Message = message,
        Embed = embedData,
        Timestamp = os.time()
    })
end

-- Processar fila do webhook respeitando rate limits :cite[1]:cite[6]
function ProcessWebhookQueue()
    local currentTime = os.time()
    
    -- Rate limiting: m√°ximo 1 mensagem a cada 2 segundos
    if currentTime - lastWebhookSend < 2 then
        return
    end
    
    if #webhookQueue > 0 then
        local messageData = table.remove(webhookQueue, 1)
        local success = SendToDiscordWebhook(messageData.Message, messageData.Embed)
        
        if success then
            lastWebhookSend = currentTime
        else
            -- Reinsere na fila se falhar
            table.insert(webhookQueue, 1, messageData)
        end
    end
end

-- Fun√ß√£o para enviar log de jogador online
function SendPlayerJoinLog(player)
    local rankName = GetPlayerRankInfo(player)
    local isAdmin = PlayerHasRequiredRank(player)
    
    local embed = {
        ["title"] = "üéÆ Jogador Conectado",
        ["description"] = player.Name .. " entrou no servidor",
        ["color"] = isAdmin and 0x00FF00 or 0xFFA500,
        ["fields"] = {
            {
                ["name"] = "Username",
                ["value"] = player.Name,
                ["inline"] = true
            },
            {
                ["name"] = "UserID",
                ["value"] = tostring(player.UserId),
                ["inline"] = true
            },
            {
                ["name"] = "Rank",
                ["value"] = rankName,
                ["inline"] = true
            }
        },
        ["footer"] = {
            ["text"] = "Sistema de Logs ‚Ä¢ " .. os.date("%H:%M:%S")
        },
        ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    QueueWebhookMessage("", embed)
end

-- Fun√ß√£o para enviar log de jogador offline
function SendPlayerLeaveLog(player)
    local rankName = GetPlayerRankInfo(player)
    local isAdmin = PlayerHasRequiredRank(player)
    
    local embed = {
        ["title"] = "üö™ Jogador Desconectado",
        ["description"] = player.Name .. " saiu do servidor",
        ["color"] = 0xFF0000,
        ["fields"] = {
            {
                ["name"] = "Username",
                ["value"] = player.Name,
                ["inline"] = true
            },
            {
                ["name"] = "UserID",
                ["value"] = tostring(player.UserId),
                ["inline"] = true
            },
            {
                ["name"] = "Rank",
                ["value"] = rankName,
                ["inline"] = true
            }
        },
        ["footer"] = {
            ["text"] = "Sistema de Logs ‚Ä¢ " .. os.date("%H:%M:%S")
        },
        ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    QueueWebhookMessage("", embed)
end

-- Fun√ß√£o para enviar log de comando executado
function SendCommandLog(player, command)
    local rankName = GetPlayerRankInfo(player)
    local isAdmin = PlayerHasRequiredRank(player)
    
    local embed = {
        ["title"] = "‚öôÔ∏è Comando Executado",
        ["description"] = "Administrador executou um comando",
        ["color"] = 0x0099FF,
        ["fields"] = {
            {
                ["name"] = "Administrador",
                ["value"] = player.Name,
                ["inline"] = true
            },
            {
                ["name"] = "Comando",
                ["value"] = "`" .. command .. "`",
                ["inline"] = true
            },
            {
                ["name"] = "Rank",
                ["value"] = rankName,
                ["inline"] = true
            }
        },
        ["footer"] = {
            ["text"] = "Sistema de Logs ‚Ä¢ " .. os.date("%H:%M:%S")
        },
        ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    QueueWebhookMessage("", embed)
end

-- Fun√ß√£o para enviar relat√≥rio completo de jogadores online
function SendPlayerListReport()
    local players = game.Players:GetPlayers()
    local onlineCount = #players
    local adminCount = 0
    
    for _, player in ipairs(players) do
        if PlayerHasRequiredRank(player) then
            adminCount += 1
        end
    end
    
    local embed = {
        ["title"] = "üìä Relat√≥rio de Jogadores Online",
        ["description"] = "Status atual do servidor",
        ["color"] = 0x7289DA,
        ["fields"] = {
            {
                ["name"] = "Total Online",
                ["value"] = tostring(onlineCount),
                ["inline"] = true
            },
            {
                ["name"] = "Administradores",
                ["value"] = tostring(adminCount),
                ["inline"] = true
            },
            {
                ["name"] = "Jogadores Comuns",
                ["value"] = tostring(onlineCount - adminCount),
                ["inline"] = true
            }
        },
        ["footer"] = {
            ["text"] = "Sistema de Logs ‚Ä¢ " .. os.date("%H:%M:%S")
        },
        ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    QueueWebhookMessage("", embed)
end

-- Fun√ß√£o para obter informa√ß√µes do rank de um jogador
function GetPlayerRankInfo(player)
    local success, result = pcall(function()
        local groupInfo = game:GetService("GroupService"):GetGroupInfoAsync(GroupID)
        if groupInfo then
            local userRole = groupInfo.Roles:GetRoleForUser(player.UserId)
            if userRole then
                return userRole.Name
            end
        end
        return "Sem Rank"
    end)
    
    if success then
        return result
    else
        return "Erro ao carregar"
    end
end

-- Fun√ß√£o para adicionar log de comando
function AddCommandLog(player, command)
    local timestamp = os.date("%H:%M:%S")
    local logEntry = {
        Player = player.Name,
        Command = command,
        Time = timestamp
    }
    
    table.insert(commandLogs, 1, logEntry)
    
    -- Limita o log aos 50 √∫ltimos comandos
    if #commandLogs > 50 then
        table.remove(commandLogs, 51)
    end
    
    -- Envia para o Discord
    SendCommandLog(player, command)
    
    -- Atualiza a interface se estiver aberta
    if OrionLib:GetWindow("CommandLogs") then
        UpdateCommandLogsUI()
    end
end

-- Criar a janela principal do OrionLib
local Window = OrionLib:MakeWindow({
    Name = "Sistema de Administra√ß√£o",
    HidePremium = false,
    SaveConfig = false,
    ConfigFolder = "AdminConfig"
})

-- Aba para listar jogadores online e seus ranks
local PlayersTab = Window:MakeTab({
    Name = "Jogadores Online",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

-- Aba para visualizar logs de comandos
local LogsTab = Window:MakeTab({
    Name = "Logs de Comandos",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

-- Aba para configura√ß√µes do Discord
local DiscordTab = Window:MakeTab({
    Name = "Configura√ß√µes Discord",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

-- Elementos da UI para jogadores
local playerListLabel = PlayersTab:AddSection({
    Name = "Jogadores Conectados"
})

local playerSections = {}

-- Elementos da UI para logs
local logsLabel = LogsTab:AddSection({
    Name = "√öltimos Comandos Executados"
})

local logsText = LogsTab:AddParagraph("", "")

-- Elementos da UI para Discord
DiscordTab:AddSection({
    Name = "Configura√ß√µes do Webhook"
})

local webhookInput = DiscordTab:AddTextbox({
    Name = "URL do Webhook",
    Default = WebhookURL,
    TextDisappear = false,
    Callback = function(value)
        WebhookURL = value
        OrionLib:MakeNotification({
            Name = "Webhook atualizado!",
            Content = "URL do webhook foi atualizado.",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
})

DiscordTab:AddToggle({
    Name = "Usar Proxy",
    Default = UseProxy,
    Callback = function(value)
        UseProxy = value
        OrionLib:MakeNotification({
            Name = "Configura√ß√£o alterada!",
            Content = "Uso de proxy " .. (value and "ativado" or "desativado"),
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
})

DiscordTab:AddButton({
    Name = "Testar Webhook",
    Callback = function()
        local success = SendToDiscordWebhook("‚úÖ Teste de webhook realizado com sucesso!", {
            ["title"] = "Teste de Conex√£o",
            ["description"] = "Seu webhook est√° funcionando corretamente!",
            ["color"] = 0x00FF00,
            ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
        })
        
        if success then
            OrionLib:MakeNotification({
                Name = "Teste bem-sucedido!",
                Content = "Webhook enviado com sucesso para o Discord.",
                Image = "rbxassetid://4483345998",
                Time = 5
            })
        else
            OrionLib:MakeNotification({
                Name = "Erro no teste",
                Content = "Falha ao enviar para o webhook. Verifique a URL.",
                Image = "rbxassetid://4483345998",
                Time = 5
            })
        end
    end
})

DiscordTab:AddButton({
    Name = "Enviar Relat√≥rio Atual",
    Callback = function()
        SendPlayerListReport()
        OrionLib:MakeNotification({
            Name = "Relat√≥rio enviado!",
            Content = "Relat√≥rio de jogadores enviado para o Discord.",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
})

-- Fun√ß√£o para atualizar a lista de jogadores
function UpdatePlayersUI()
    for _, section in pairs(playerSections) do
        section:Remove()
    end
    playerSections = {}
    
    for _, player in ipairs(game.Players:GetPlayers()) do
        local rankName = GetPlayerRankInfo(player)
        local isAdmin = PlayerHasRequiredRank(player)
        
        local adminStatus = isAdmin and "‚úÖ" or "‚ùå"
        local playerColor = isAdmin and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255)
        
        local section = PlayersTab:AddSection({
            Name = player.Name .. " " .. adminStatus,
            Default = false
        })
        
        section:AddLabel("Rank: " .. rankName)
        section:AddLabel("UserID: " .. player.UserId)
        
        playerSections[player.Name] = section
        playerData[player.Name] = {
            Rank = rankName,
            IsAdmin = isAdmin
        }
    end
end

-- Fun√ß√£o para atualizar os logs de comandos
function UpdateCommandLogsUI()
    local logText = ""
    
    for i, log in ipairs(commandLogs) do
        logText = logText .. string.format("[%s] %s: %s\n", log.Time, log.Player, log.Command)
    end
    
    logsText:Set(logText)
end

-- Monitorar quando jogadores entram e saem
game.Players.PlayerAdded:Connect(function(player)
    wait(1) -- Espera um pouco para carregar as informa√ß√µes
    UpdatePlayersUI()
    SendPlayerJoinLog(player)
    
    -- Monitorar comandos deste jogador
    player.Chatted:Connect(function(message)
        if string.sub(message, 1, 1) == ":" then
            AddCommandLog(player, message)
        end
    end)
end)

game.Players.PlayerRemoving:Connect(function(player)
    wait(1) -- Espera um pouco para atualizar
    UpdatePlayersUI()
    SendPlayerLeaveLog(player)
end)

-- Processar fila do webhook periodicamente
game:GetService("RunService").Heartbeat:Connect(function()
    ProcessWebhookQueue()
end)

-- Atualizar a interface periodicamente
game:GetService("RunService").Heartbeat:Connect(function()
    UpdatePlayersUI()
    UpdateCommandLogsUI()
end)

-- Inicializar a interface
UpdatePlayersUI()
UpdateCommandLogsUI()

-- Adicionar bot√£o de atualiza√ß√£o manual
PlayersTab:AddButton({
    Name = "Atualizar Lista",
    Callback = function()
        UpdatePlayersUI()
        OrionLib:MakeNotification({
            Name = "Lista atualizada!",
            Content = "Lista de jogadores foi atualizada.",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
})

-- Adicionar bot√£o para limpar logs
LogsTab:AddButton({
    Name = "Limpar Logs",
    Callback = function()
        commandLogs = {}
        UpdateCommandLogsUI()
        OrionLib:MakeNotification({
            Name = "Logs limpos!",
            Content = "Todos os logs de comandos foram removidos.",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
})

-- Inicializar a OrionLib
OrionLib:Init()

-- Notifica√ß√£o de inicializa√ß√£o
OrionLib:MakeNotification({
    Name = "Sistema carregado!",
    Content = "Sistema de logs para Discord inicializado com sucesso.",
    Image = "rbxassetid://4483345998",
    Time = 5
})

-- Enviar relat√≥rio inicial
SendPlayerListReport()

print("Sistema de logs para Discord carregado com sucesso!")
