-- modo seguro
getgenv().SecureMode = false:cite[2]

-- Carregar a biblioteca Rayfield
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))():cite[5]

-- id do grupo
local GroupID = 16168861
local AllowedRanks = {"High Rank Admin", "Low Rank Admin", "Lower Rank Admin"}

-- Configuracao do discord
local WebhookURL = "https://discord.com/api/webhooks/1411857943791538226/xkJGodU0er5FKz3I0SuMEe3o-MW0rU4F-2jIlGSRJCKkDMsS3jcKmYRvcWS4P4EONl7t"
local UseProxy = true
local ProxyURL = "https://webhook.lewistehminerz.dev/api"

-- armazenamento de dado 
local playerData = {}
local commandLogs = {}
local lastWebhookSend = 0
local webhookQueue = {}

-- janela rayfield
local Window = Rayfield:CreateWindow({
    Name = "Sistema de Administra√ß√£o",
    LoadingTitle = "Carregando Sistema de Administra√ß√£o",
    LoadingSubtitle = "por " .. game.Players.LocalPlayer.Name,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "AdminSystemConfig",
        FileName = "Configura√ß√µes"
    },
    Discord = {
        Enabled = false,
        Invite = "sirius",
        RememberJoins = true
    },
    KeySystem = false,
    Theme = "Default":cite[6],
    ToggleUIKeybind = "RightControl":cite[9]
}):cite[10]

-- verificar permiss√£o
function PlayerHasRequiredRank(player)
    local success, result = pcall(function()
        local groupInfo = game:GetService("GroupService"):GetGroupInfoAsync(GroupID)
        if groupInfo then
            local userRole = groupInfo.Roles:GetRoleForUser(player.UserId)
            if userRole then
                for _, allowedRank in ipairs(AllowedRanks) do
                    if userRole.Name == allowedRank then
                        return true
                    end
                end
            end
        end
        return false
    end)
    return success and result
end

-- logs discord
function SendToDiscordWebhook(message, embedData)
    local actualURL = WebhookURL
    if UseProxy then
        actualURL = string.gsub(actualURL, "https://discord.com/api", ProxyURL)
    end

    local data = {
        ["content"] = message,
        ["embeds"] = embedData and {embedData} or nil,
        ["username"] = "Sistema de Administra√ß√£o",
        ["avatar_url"] = "https://cdn.discordapp.com/attachments/1162122057362964573/1170503055503015966/asdasdasdasdadaddw.png"
    }

    local success, err = pcall(function()
        local httpService = game:GetService("HttpService")
        local jsonData = httpService:JSONEncode(data)
        
        httpService:PostAsync(actualURL, jsonData)
    end)
    
    if not success then
        warn("Erro ao enviar para webhook: " .. tostring(err))
        return false
    end
    return true
end

-- add mensagem
function QueueWebhookMessage(message, embedData)
    table.insert(webhookQueue, {
        Message = message,
        Embed = embedData,
        Timestamp = os.time()
    })
end

-- Processar fila do webhook respeitando rate limits
function ProcessWebhookQueue()
    local currentTime = os.time()
    
    -- Rate limiting: m√°ximo 1 mensagem a cada 2 segundos
    if currentTime - lastWebhookSend < 2 then
        return
    end
    
    if #webhookQueue > 0 then
        local messageData = table.remove(webhookQueue, 1)
        local success = SendToDiscordWebhook(messageData.Message, messageData.Embed)
        
        if success then
            lastWebhookSend = currentTime
        else
            table.insert(webhookQueue, 1, messageData)
        end
    end
end

-- enviar log de ranks
function SendPlayerJoinLog(player)
    local rankName = GetPlayerRankInfo(player)
    local isAdmin = PlayerHasRequiredRank(player)
    
    local embed = {
        ["title"] = "üéÆ Jogador Conectado",
        ["description"] = player.Name .. " entrou no servidor",
        ["color"] = isAdmin and 0x00FF00 or 0xFFA500,
        ["fields"] = {
            {
                ["name"] = "Username",
                ["value"] = player.Name,
                ["inline"] = true
            },
            {
                ["name"] = "UserID",
                ["value"] = tostring(player.UserId),
                ["inline"] = true
            },
            {
                ["name"] = "Rank",
                ["value"] = rankName,
                ["inline"] = true
            }
        },
        ["footer"] = {
            ["text"] = "Sistema de Logs ‚Ä¢ " .. os.date("%H:%M:%S")
        },
        ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    QueueWebhookMessage("", embed)
end

-- enviar log de saida
function SendPlayerLeaveLog(player)
    local rankName = GetPlayerRankInfo(player)
    local isAdmin = PlayerHasRequiredRank(player)
    
    local embed = {
        ["title"] = "üö™ Jogador Desconectado",
        ["description"] = player.Name .. " saiu do servidor",
        ["color"] = 0xFF0000,
        ["fields"] = {
            {
                ["name"] = "Username",
                ["value"] = player.Name,
                ["inline"] = true
            },
            {
                ["name"] = "UserID",
                ["value"] = tostring(player.UserId),
                ["inline"] = true
            },
            {
                ["name"] = "Rank",
                ["value"] = rankName,
                ["inline"] = true
            }
        },
        ["footer"] = {
            ["text"] = "Sistema de Logs ‚Ä¢ " .. os.date("%H:%M:%S")
        },
        ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    QueueWebhookMessage("", embed)
end

-- enviar comando executado
function SendCommandLog(player, command)
    local rankName = GetPlayerRankInfo(player)
    local isAdmin = PlayerHasRequiredRank(player)
    
    local embed = {
        ["title"] = "‚öôÔ∏è Comando Executado",
        ["description"] = "Administrador executou um comando",
        ["color"] = 0x0099FF,
        ["fields"] = {
            {
                ["name"] = "Administrador",
                ["value"] = player.Name,
                ["inline"] = true
            },
            {
                ["name"] = "Comando",
                ["value"] = "`" .. command .. "`",
                ["inline"] = true
            },
            {
                ["name"] = "Rank",
                ["value"] = rankName,
                ["inline"] = true
            }
        },
        ["footer"] = {
            ["text"] = "Sistema de Logs ‚Ä¢ " .. os.date("%H:%M:%S")
        },
        ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    QueueWebhookMessage("", embed)
end

-- relatorio de ranks online
function SendPlayerListReport()
    local players = game.Players:GetPlayers()
    local onlineCount = #players
    local adminCount = 0
    
    for _, player in ipairs(players) do
        if PlayerHasRequiredRank(player) then
            adminCount += 1
        end
    end
    
    local embed = {
        ["title"] = "üìä Relat√≥rio de Jogadores Online",
        ["description"] = "Status atual do servidor",
        ["color"] = 0x7289DA,
        ["fields"] = {
            {
                ["name"] = "Total Online",
                ["value"] = tostring(onlineCount),
                ["inline"] = true
            },
            {
                ["name"] = "Administradores",
                ["value"] = tostring(adminCount),
                ["inline"] = true
            },
            {
                ["name"] = "Jogadores Comuns",
                ["value"] = tostring(onlineCount - adminCount),
                ["inline"] = true
            }
        },
        ["footer"] = {
            ["text"] = "Sistema de Logs ‚Ä¢ " .. os.date("%H:%M:%S")
        },
        ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    QueueWebhookMessage("", embed)
end

-- Fun√ß√£o para obter informa√ß√µes do rank de um jogador
function GetPlayerRankInfo(player)
    local success, result = pcall(function()
        local groupInfo = game:GetService("GroupService"):GetGroupInfoAsync(GroupID)
        if groupInfo then
            local userRole = groupInfo.Roles:GetRoleForUser(player.UserId)
            if userRole then
                return userRole.Name
            end
        end
        return "Sem Rank"
    end)
    
    if success then
        return result
    else
        return "Erro ao carregar"
    end
end

-- add log
function AddCommandLog(player, command)
    local timestamp = os.date("%H:%M:%S")
    local logEntry = {
        Player = player.Name,
        Command = command,
        Time = timestamp
    }
    
    table.insert(commandLogs, 1, logEntry)
    
    if #commandLogs > 50 then
        table.remove(commandLogs, 51)
    end
    
    SendCommandLog(player, command)
    UpdateCommandLogsUI()
end

-- Criar abas do Rayfield
local PlayersTab = Window:CreateTab("Jogadores Online", 4483362458) -- Title, Image:cite[10]
local LogsTab = Window:CreateTab("Logs de Comandos", 4483362458)
local DiscordTab = Window:CreateTab("Configura√ß√µes Discord", 4483362458)
local AdminTab = Window:CreateTab("Comandos Admin", 4483362458)

-- Elementos da UI para jogadores
local playerSections = {}
local playersList = {}

-- Se√ß√£o para lista de jogadores
local PlayersSection = PlayersTab:CreateSection("Jogadores Conectados"):cite[10]

-- Fun√ß√£o para atualizar a lista de jogadores na UI
function UpdatePlayersUI()
    for _, playerFrame in pairs(playersList) do
        playerFrame:Destroy()
    end
    playersList = {}
    
    for _, player in ipairs(game.Players:GetPlayers()) do
        local rankName = GetPlayerRankInfo(player)
        local isAdmin = PlayerHasRequiredRank(player)
        
        local playerFrame = PlayersTab:CreateParagraph({
            Title = player.Name .. " " .. (isAdmin and "‚úÖ" or "‚ùå"),
            Content = "Rank: " .. rankName .. " | UserID: " .. player.UserId
        }):cite[9]
        
        table.insert(playersList, playerFrame)
        playerData[player.Name] = {
            Rank = rankName,
            IsAdmin = isAdmin
        }
    end
end

-- Elementos da UI para logs
local LogsSection = LogsTab:CreateSection("√öltimos Comandos Executados")
local logsText = LogsTab:CreateParagraph({
    Title = "Hist√≥rico de Comandos",
    Content = "Carregando..."
}):cite[9]

-- logs2
function UpdateCommandLogsUI()
    local logContent = ""
    
    for i, log in ipairs(commandLogs) do
        logContent = logContent .. string.format("[%s] %s: %s\n", log.Time, log.Player, log.Command)
    end
    
    logsText:Set({Title = "Hist√≥rico de Comandos", Content = logContent})
end

-- Elemento da ui discord
local DiscordSection = DiscordTab:CreateSection("Configura√ß√µes do Webhook")

local webhookInput = DiscordTab:CreateInput({
    Name = "URL do Webhook",
    PlaceholderText = WebhookURL,
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        WebhookURL = Text
        Rayfield:Notify({
            Title = "Webhook atualizado!",
            Content = "URL do webhook foi atualizado.",
            Duration = 6.5,
            Image = 4483362458,
        }):cite[9]
    end,
}):cite[9]

local proxyToggle = DiscordTab:CreateToggle({
    Name = "Usar Proxy",
    CurrentValue = UseProxy,
    Callback = function(Value)
        UseProxy = Value
        Rayfield:Notify({
            Title = "Configura√ß√£o alterada!",
            Content = "Uso de proxy " .. (Value and "ativado" or "desativado"),
            Duration = 6.5,
            Image = 4483362458,
        })
    end,
}):cite[9]

DiscordTab:CreateButton({
    Name = "Testar Webhook",
    Callback = function()
        local success = SendToDiscordWebhook("‚úÖ Teste de webhook realizado com sucesso!", {
            ["title"] = "Teste de Conex√£o",
            ["description"] = "Seu webhook est√° funcionando corretamente!",
            ["color"] = 0x00FF00,
            ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
        })
        
        if success then
            Rayfield:Notify({
                Title = "Teste bem-sucedido!",
                Content = "Webhook enviado com sucesso para o Discord.",
                Duration = 6.5,
                Image = 4483362458,
            })
        else
            Rayfield:Notify({
                Title = "Erro no teste",
                Content = "Falha ao enviar para o webhook. Verifique a URL.",
                Duration = 6.5,
                Image = 4483362458,
            })
        end
    end,
}):cite[9]

DiscordTab:CreateButton({
    Name = "Enviar Relat√≥rio Atual",
    Callback = function()
        SendPlayerListReport()
        Rayfield:Notify({
            Title = "Relat√≥rio enviado!",
            Content = "Relat√≥rio de jogadores enviado para o Discord.",
            Duration = 6.5,
            Image = 4483362458,
        })
    end,
}):cite[9]

-- elemento comandos de ranks
local AdminSection = AdminTab:CreateSection("Comandos de Administra√ß√£o")

local loopkillInput = AdminTab:CreateInput({
    Name = "Loopkill Player",
    PlaceholderText = "Nome do jogador",
    RemoveTextAfterFocusLost = false,
    Callback = function(playerName)
        if PlayerHasRequiredRank(game.Players.LocalPlayer) then
            local targetPlayer = game.Players:FindFirstChild(playerName)
            if targetPlayer then
                -- fun√ß√£o
                Rayfield:Notify({
                    Title = "Loopkill ativado!",
                    Content = "Loopkill ativado para " .. targetPlayer.Name,
                    Duration = 6.5,
                    Image = 4483362458,
                })
                AddCommandLog(game.Players.LocalPlayer, ":loopkill " .. playerName)
            else
                Rayfield:Notify({
                    Title = "Jogador n√£o encontrado",
                    Content = "O jogador " .. playerName .. " n√£o foi encontrado.",
                    Duration = 6.5,
                    Image = 4483362458,
                })
            end
        else
            Rayfield:Notify({
                Title = "Sem permiss√£o",
                Content = "Voc√™ n√£o tem permiss√£o para usar este comando.",
                Duration = 6.5,
                Image = 4483362458,
            })
        end
    end,
}):cite[9]

AdminTab:CreateButton({
    Name = "Atualizar Lista de Jogadores",
    Callback = function()
        UpdatePlayersUI()
        Rayfield:Notify({
            Title = "Lista atualizada!",
            Content = "Lista de jogadores foi atualizada.",
            Duration = 6.5,
            Image = 4483362458,
        })
    end,
}):cite[9]

AdminTab:CreateButton({
    Name = "Limpar Logs",
    Callback = function()
        commandLogs = {}
        UpdateCommandLogsUI()
        Rayfield:Notify({
            Title = "Logs limpos!",
            Content = "Todos os logs de comandos foram removidos.",
            Duration = 6.5,
            Image = 4483362458,
        })
    end,
}):cite[9]

-- monitorar quando jogadores entram e saem
game.Players.PlayerAdded:Connect(function(player)
    task.wait(1)
    UpdatePlayersUI()
    SendPlayerJoinLog(player)
    
    player.Chatted:Connect(function(message)
        if string.sub(message, 1, 1) == ":" then
            AddCommandLog(player, message)
        end
    end)
end)

game.Players.PlayerRemoving:Connect(function(player)
    task.wait(1)
    UpdatePlayersUI()
    SendPlayerLeaveLog(player)
end)

-- Processar fila do webhook periodicamente
game:GetService("RunService").Heartbeat:Connect(function()
    ProcessWebhookQueue()
    UpdatePlayersUI()
    UpdateCommandLogsUI()
end)

-- Inicializar a interface
UpdatePlayersUI()
UpdateCommandLogsUI()

-- Notifica√ß√£o de inicializa√ß√£o
Rayfield:Notify({
    Title = "Sistema carregado!",
    Content = "Sistema de administra√ß√£o com Rayfield inicializado com sucesso.",
    Duration = 6.5,
    Image = 4483362458,
}):cite[9]

-- Enviar relat√≥rio inicial
SendPlayerListReport()

-- Carregar configura√ß√£o salva
Rayfield:LoadConfiguration():cite[2]

print("Sistema de administra√ß√£o com Rayfield carregado com sucesso!")
